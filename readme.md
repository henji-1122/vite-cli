
##### 基于koa开发一个静态的web服务器
* 模拟Vite实现原理
* 核心：开发阶段不需要本地打包，根据需要请求服务器编译单文件组件(未处理样式和图片模块)



##### Vite

###### Vite 概念
* Vite是一个面向现代浏览器的一个更轻、更快的web应用开发工具
* 她基于ECMAScript标准原生模块系统(ES Modules)实现
* 他的出现是为了解决webpack在开发阶段使用webpack-dev-server冷启动时间过长、webpack热更新HMR反应速度慢的问题，使用vite创建的项目就是普通的vue3的应用没有太多特殊的地方，相比vue-cli创建的项目也少了很多的配置文件和依赖


###### vite项目依赖
* vite :命令行工具
* @vue/compiler-sfc ：编译项目中.vue单文件组件(vue2中使用的是vue-template-compiler)


###### 基础使用(子命令)
* vite serve:开启一个用于开发的web服务器，在启动服务时不需要编译所有的代码文件，启动速度非常快：
    - 运行vite serve时不需要打包直接开启web服务器，当浏览器请求服务器，例如请求一个单文件组件，此时在服务器端编译单文件组价，然后将编译的结果返回给浏览器，这里的编译是在服务器端，另外模块的处理是在请求到服务器端处理的
    - vue-cli创建的应用，在开发时启动web服务时使用的是vue-cli-service serve，当运行时内部会使用webpack打包所有的模块，如果模块比较多的话打包速度会很慢，将打包的结果存到内存中才会开启开发的web服务器。浏览器请求web服务器，会把内存中打包的结果直接返回给浏览器，webpack是将所有的模块提前打包到bundle中，也就是说不管模块是否被执行是否使用到，都会打包和编译到bundle中,随着项目越来越大bundle也越来越大，打包的速度也自然越来越慢
    - vite使用浏览器原生支持的ES Module模块化的特性省略了对模块化的打包，对于需要编译的模块，例如单文件组件、样式那块等，vite采用另一种及时编译的模式，也就是只有具体请求某个模块时才会在服务端编译这个模块，这种及时编译的好处主要体现在按需编译，速度会更快
* vite build：


###### HMR
* Vite HMR
  - Vite默认也支持HMR模块热更新，相对于webpack中的HMR性能更好，因为vite只需要立即编译当前所修改的文件即可，编译速度会很快
* Webpack HMR
  - 修改某个文件后会自动以这个文件为入口重新build一次，所有涉及到的依赖也都会被加载一遍，相对速度较慢


###### Build
* vite build：生产模式下打包
  - Rollup：内部采用Rollup打包，最终还是将文件提前打包编译到一起
  - Dynamic import：代码切割的需求采用的是原生的动态导入的方式实现的，所以打包结果只能够支持现代浏览器
    * Polyfill：动态导入使用的是Polyfill


###### 打包or不打包
- 使用 webpack打包的两个原因：
  * 浏览器环境并不支持模块化
  * 零散的模块文件会产生大量的http请求
- 随着现代浏览器对ES标准支持的逐渐完善，第一个问题慢慢不存在了，现代浏览器慢慢都是支持ES Module特性的
- 第二个问题，之前打包目的是当js文件比较多的时候，每个js文件都会向服务器发送一次请求，每个请求都要创建一个连接，为了减少请求次数所以打包成了一个文件，这个问题http2已经解决，他可以复用连接


###### 浏览器对ES Module的支持情况
* IE不支持，如果想要IE11支持的话还需要使用之前的方式打包
* 现代浏览器都是支持ES Module的


###### 开箱即用
* TypeScript-内置支持
* less/sass/stylus/postcss-内置支持(需要单独安装)
* JSX
* Web Assembly


##### 总结：

###### Vite特性(主要体现在：提升开发者在开发过程中的体验)
* 快速冷启动(web开发服务器不需要等待，可以立即启动)
* 模块热更新(几乎是实时的)
* 按需编译(避免用不到的模块)
* 开箱即用(避免各种loader和plugin的配置)


##### 运行测试
  - 进入vue3创建的项目
  - 使用vite-cli开启web静态服务器：vite-cli
  - 在浏览器中访问对应的端口预览页面